import * as flSuperModule from "./FLNodeSuper";
import * as flExpModule from "./FLNodeExpression";
import { stringIgnoringTags, stringSplitIgnoringTags } from "../splitString";
import { FLNodeAssignment } from "../../dist/FLNode/FLNodeAssignment";

enum ConditionalType {
    equal = "equal",
    larger = "larger",
    lower = "lower",
    largerEqual = "largerEqual",
    lowerEqual = "lowerEqual",
    boolean = "boolean"
}

export class FLNodeConditional extends flSuperModule.FLNode {

    conditionalType: ConditionalType;
    conditionalSymbol: string | null;

    static syntaxSymbols = {
        equal: "==",
        larger: ">",
        lower: "<",
        largerEqual: ">=",
        lowerEqual: "<=",
    };
    
    constructor(
        type: flSuperModule.FLNodeTypeEnum,
        text: flSuperModule.BlockTextInterface,
        nodeLine?: number) {

        super(type, text);
        if (nodeLine) {
            this.nodeLine = nodeLine;
        }

        this.createChildren();
    }

    // Create children
    createChildren(): flSuperModule.FLNodeInterface[] {

        // Check the conditional type
        if (this.text.includes(FLNodeConditional.syntaxSymbols.equal)) {
            this.conditionalType = ConditionalType.equal;
            this.conditionalSymbol = FLNodeConditional.syntaxSymbols.equal

        } else if (this.text.includes(FLNodeConditional.syntaxSymbols.larger)) {
            this.conditionalType = ConditionalType.larger;
            this.conditionalSymbol = FLNodeConditional.syntaxSymbols.larger

        } else if (this.text.includes(FLNodeConditional.syntaxSymbols.lower)) {
            this.conditionalType = ConditionalType.lower;
            this.conditionalSymbol = FLNodeConditional.syntaxSymbols.lower

        } else if (this.text.includes(FLNodeConditional.syntaxSymbols.largerEqual)) {
            this.conditionalType = ConditionalType.largerEqual;
            this.conditionalSymbol = FLNodeConditional.syntaxSymbols.largerEqual

        } else if (this.text.includes(FLNodeConditional.syntaxSymbols.lowerEqual)) {
            this.conditionalType = ConditionalType.lowerEqual;
            this.conditionalSymbol = FLNodeConditional.syntaxSymbols.lowerEqual

        } else {
            this.conditionalType = ConditionalType.boolean;
            this.conditionalSymbol = null;
        }

        // If conditional symbol is found then create multiple children
        if (this.conditionalType === ConditionalType.boolean) {
            const onlyChild = new flExpModule.FLNodeExpression(
                flSuperModule.FLNodeTypeEnum.Expression,
                this.text
            )
            return [onlyChild]
        } else {
            // Divide to left and right child while ignoring the enclosure symbols
            const enclosureStartSymbol = flExpModule.FLNodeExpression.syntaxSymbols.enclosureStart;
            const enclosureEndSymbol = flExpModule.FLNodeExpression.syntaxSymbols.enclosureEnd;

            if (this.conditionalSymbol) {
                throw "No conditional symbol assigned before spliting the text to children texts"
            }

            const childrenText = stringSplitIgnoringTags(
                this.text,
                this.conditionalSymbol as string,
                [[enclosureStartSymbol, enclosureEndSymbol]]
            )

            this.children = childrenText.map((childText) => {
                return new flExpModule.FLNodeExpression(
                    flSuperModule.FLNodeTypeEnum.Expression,
                    childText
                )
            })

            if (this.children.length !== 2) {
                throw "wrong number of children nodes for conditional statement"
            }

            return this.children
        }
    }

    run(scopeEnvironment: object): [unknown, string] {

        // Execute the children and give either 1 or 0 for boolean value
        if (this.children.length === 1) {
            return (this.children[0].run(scopeEnvironment));
        } else {
            const leftChildValue = this.children[0].run(scopeEnvironment)[0];
            const rightChildValue = this.children[1].run(scopeEnvironment)[0];

            let outputValue: boolean;

            switch(this.conditionalType) {
                case ConditionalType.larger:
                    outputValue = leftChildValue > rightChildValue;
                    break;
                case ConditionalType.lower:
                    outputValue = leftChildValue < rightChildValue;
                    break;
                case ConditionalType.largerEqual:
                    outputValue = leftChildValue >= rightChildValue;
                    break;
                case ConditionalType.lowerEqual:
                    outputValue = leftChildValue <= rightChildValue;
                    break;
                default:
                    throw "No conditional type could be found for evaluating the value"
            }

            if (outputValue) {
                return ([1, ""]);
            } else {
                return ([0, ""]);
            }

        }

        return ([,""]);
    }

    runOneStep(
        inputCurrentLine: number,
        inputScopeEnvironment: object,
        inputCallStack: string[]) {

        if (this.runCycleStatus === flSuperModule.RunCycleStatusEnum.evaluate) {
            this.runCycleStatus = flSuperModule.RunCycleStatusEnum.popOffStack;
            return {
                currentLine: this.nodeLine,
                scopeEnvironment: inputScopeEnvironment,
                callStack: inputCallStack,
                output: null}
        } 

        const outputCallStack = flSuperModule.genericStateChange(
            this, inputCallStack)
        
        return ({
            currentLine: this.nodeLine,
            scopeEnvironment: inputScopeEnvironment,
            callStack: outputCallStack,
            output: null})
    }
}